/*
 *  Do not edit this file 
 *  Generated by TraceGen
 */
#ifndef UTE_AVL_MODULE_HEADER
#define UTE_AVL_MODULE_HEADER
#include "ute_module.h"
#if !defined(UT_DIRECT_TRACE_REGISTRATION)
#include "jni.h"
#endif /* !defined(UT_DIRECT_TRACE_REGISTRATION) */
#ifndef UT_TRACE_OVERHEAD
#define UT_TRACE_OVERHEAD 1
#endif
#ifndef UT_THREAD
#define UT_THREAD(thr) (void *)thr
#endif /* UT_THREAD */
#ifndef UT_STR
#define UT_STR(arg) #arg
#endif
#ifdef __cplusplus
extern "C" {
#endif

#ifdef __clang__
#include <unistd.h>
#define Trace_Unreachable() _exit(-1)
#else
#define Trace_Unreachable()
#endif

#if defined(UT_DIRECT_TRACE_REGISTRATION)
int32_t registeravlWithTrace(UtInterface * utIntf, UtModuleInfo* containerName);
int32_t deregisteravlWithTrace(UtInterface * utIntf);
#define UT_MODULE_LOADED(utIntf) registeravlWithTrace((utIntf), NULL);
#define UT_MODULE_UNLOADED(utIntf) deregisteravlWithTrace((utIntf));
#define UT_AVL_MODULE_LOADED(utIntf) registeravlWithTrace((utIntf), NULL);
#define UT_AVL_MODULE_UNLOADED(utIntf) deregisteravlWithTrace((utIntf));
#else /* defined(UT_DIRECT_TRACE_REGISTRATION) */
int32_t registeravlWithTrace(JavaVM * vm, UtModuleInfo* containerName);
int32_t deregisteravlWithTrace(JavaVM * vm);
#define UT_MODULE_LOADED(vm) registeravlWithTrace((JavaVM *)(vm), NULL);
#define UT_MODULE_UNLOADED(vm) deregisteravlWithTrace((JavaVM *)(vm));
#define UT_AVL_MODULE_LOADED(vm) registeravlWithTrace((JavaVM *)(vm), NULL);
#define UT_AVL_MODULE_UNLOADED(vm) deregisteravlWithTrace((JavaVM *)(vm));
#endif /* defined(UT_DIRECT_TRACE_REGISTRATION) */

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_findRightMostLeaf_Entry(P1, P2, P3) do { /* tracepoint name: avl.0 */ \
	if ((unsigned char) avl_UtActive[0] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((0u << 8) | avl_UtActive[0]), "\6\6\6", P1, P2, P3);} \
	} while(0)
#else
#define Trc_AVL_findRightMostLeaf_Entry(P1, P2, P3)   /* tracepoint name: avl.0 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_findRightMostLeaf_NotFound() do { /* tracepoint name: avl.1 */ \
	if ((unsigned char) avl_UtActive[1] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((1u << 8) | avl_UtActive[1]), NULL);} \
	} while(0)
#else
#define Trc_AVL_findRightMostLeaf_NotFound()   /* tracepoint name: avl.1 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_findRightMostLeaf_Exit(P1) do { /* tracepoint name: avl.2 */ \
	if ((unsigned char) avl_UtActive[2] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((2u << 8) | avl_UtActive[2]), "\6", P1);} \
	} while(0)
#else
#define Trc_AVL_findRightMostLeaf_Exit(P1)   /* tracepoint name: avl.2 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_rotate_Entry(P1, P2, P3, P4) do { /* tracepoint name: avl.3 */ \
	if ((unsigned char) avl_UtActive[3] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((3u << 8) | avl_UtActive[3]), "\6\6\6\6", P1, P2, P3, P4);} \
	} while(0)
#else
#define Trc_AVL_rotate_Entry(P1, P2, P3, P4)   /* tracepoint name: avl.3 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_rotate_Exit(P1) do { /* tracepoint name: avl.4 */ \
	if ((unsigned char) avl_UtActive[4] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((4u << 8) | avl_UtActive[4]), "\6", P1);} \
	} while(0)
#else
#define Trc_AVL_rotate_Exit(P1)   /* tracepoint name: avl.4 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_doubleRotate_Entry(P1, P2, P3, P4) do { /* tracepoint name: avl.5 */ \
	if ((unsigned char) avl_UtActive[5] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((5u << 8) | avl_UtActive[5]), "\6\6\6\6", P1, P2, P3, P4);} \
	} while(0)
#else
#define Trc_AVL_doubleRotate_Entry(P1, P2, P3, P4)   /* tracepoint name: avl.5 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_doubleRotate_Exit(P1) do { /* tracepoint name: avl.6 */ \
	if ((unsigned char) avl_UtActive[6] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((6u << 8) | avl_UtActive[6]), "\6", P1);} \
	} while(0)
#else
#define Trc_AVL_doubleRotate_Exit(P1)   /* tracepoint name: avl.6 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_rebalance_Entry(P1, P2, P3, P4, P5) do { /* tracepoint name: avl.7 */ \
	if ((unsigned char) avl_UtActive[7] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((7u << 8) | avl_UtActive[7]), "\6\6\6\6\6", P1, P2, P3, P4, P5);} \
	} while(0)
#else
#define Trc_AVL_rebalance_Entry(P1, P2, P3, P4, P5)   /* tracepoint name: avl.7 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_rebalance_Exit(P1) do { /* tracepoint name: avl.8 */ \
	if ((unsigned char) avl_UtActive[8] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((8u << 8) | avl_UtActive[8]), "\6", P1);} \
	} while(0)
#else
#define Trc_AVL_rebalance_Exit(P1)   /* tracepoint name: avl.8 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_insertNode_Entry(P1, P2, P3, P4, P5) do { /* tracepoint name: avl.9 */ \
	if ((unsigned char) avl_UtActive[9] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((9u << 8) | avl_UtActive[9]), "\6\6\6\6\6", P1, P2, P3, P4, P5);} \
	} while(0)
#else
#define Trc_AVL_insertNode_Entry(P1, P2, P3, P4, P5)   /* tracepoint name: avl.9 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_insertNode_Trivial(P1) do { /* tracepoint name: avl.10 */ \
	if ((unsigned char) avl_UtActive[10] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((10u << 8) | avl_UtActive[10]), "\6", P1);} \
	} while(0)
#else
#define Trc_AVL_insertNode_Trivial(P1)   /* tracepoint name: avl.10 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_insertNode_Exists(P1) do { /* tracepoint name: avl.11 */ \
	if ((unsigned char) avl_UtActive[11] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((11u << 8) | avl_UtActive[11]), "\6", P1);} \
	} while(0)
#else
#define Trc_AVL_insertNode_Exists(P1)   /* tracepoint name: avl.11 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_insertNode_Recursive(P1) do { /* tracepoint name: avl.12 */ \
	if ((unsigned char) avl_UtActive[12] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((12u << 8) | avl_UtActive[12]), "\6", P1);} \
	} while(0)
#else
#define Trc_AVL_insertNode_Recursive(P1)   /* tracepoint name: avl.12 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_findNode_Entry(P1, P2, P3) do { /* tracepoint name: avl.13 */ \
	if ((unsigned char) avl_UtActive[13] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((13u << 8) | avl_UtActive[13]), "\6\6\6", P1, P2, P3);} \
	} while(0)
#else
#define Trc_AVL_findNode_Entry(P1, P2, P3)   /* tracepoint name: avl.13 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_findNode_Exit(P1) do { /* tracepoint name: avl.14 */ \
	if ((unsigned char) avl_UtActive[14] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((14u << 8) | avl_UtActive[14]), "\6", P1);} \
	} while(0)
#else
#define Trc_AVL_findNode_Exit(P1)   /* tracepoint name: avl.14 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_deleteNode_Entry(P1, P2, P3, P4, P5) do { /* tracepoint name: avl.15 */ \
	if ((unsigned char) avl_UtActive[15] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((15u << 8) | avl_UtActive[15]), "\6\6\6\6\6", P1, P2, P3, P4, P5);} \
	} while(0)
#else
#define Trc_AVL_deleteNode_Entry(P1, P2, P3, P4, P5)   /* tracepoint name: avl.15 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_deleteNode_NotInTree() do { /* tracepoint name: avl.16 */ \
	if ((unsigned char) avl_UtActive[16] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((16u << 8) | avl_UtActive[16]), NULL);} \
	} while(0)
#else
#define Trc_AVL_deleteNode_NotInTree()   /* tracepoint name: avl.16 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_deleteNode_Removed(P1) do { /* tracepoint name: avl.17 */ \
	if ((unsigned char) avl_UtActive[17] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((17u << 8) | avl_UtActive[17]), "\6", P1);} \
	} while(0)
#else
#define Trc_AVL_deleteNode_Removed(P1)   /* tracepoint name: avl.17 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_AVL_deleteNode_Recursive(P1) do { /* tracepoint name: avl.18 */ \
	if ((unsigned char) avl_UtActive[18] != 0){ \
		avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, ((18u << 8) | avl_UtActive[18]), "\6", P1);} \
	} while(0)
#else
#define Trc_AVL_deleteNode_Recursive(P1)   /* tracepoint name: avl.18 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Assert_AVL_true(P1) do { /* tracepoint name: avl.19 */ \
	if ((unsigned char) avl_UtActive[19] != 0){ \
		if ((P1)) { /* assertion satisfied */ } else { \
			if (avl_UtModuleInfo.intf != NULL) { \
				avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, (UT_SPECIAL_ASSERTION | (19u << 8) | avl_UtActive[19]), "\377\4\377", __FILE__, __LINE__, UT_STR(((P1)))); \
				Trace_Unreachable(); \
			} else { \
				fprintf(stderr, "** ASSERTION FAILED ** avl.19 at %s:%d Assert_AVL_true%s\n", __FILE__, __LINE__, UT_STR(((P1)))); \
			} \
		}} \
	} while(0)
#else
#define Assert_AVL_true(P1)   /* tracepoint name: avl.19 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Assert_AVL_false(P1) do { /* tracepoint name: avl.20 */ \
	if ((unsigned char) avl_UtActive[20] != 0){ \
		if (!(P1)) { /* assertion satisfied */ } else { \
			if (avl_UtModuleInfo.intf != NULL) { \
				avl_UtModuleInfo.intf->Trace((void *)NULL, &avl_UtModuleInfo, (UT_SPECIAL_ASSERTION | (20u << 8) | avl_UtActive[20]), "\377\4\377", __FILE__, __LINE__, UT_STR((!(P1)))); \
				Trace_Unreachable(); \
			} else { \
				fprintf(stderr, "** ASSERTION FAILED ** avl.20 at %s:%d Assert_AVL_false%s\n", __FILE__, __LINE__, UT_STR((!(P1)))); \
			} \
		}} \
	} while(0)
#else
#define Assert_AVL_false(P1)   /* tracepoint name: avl.20 */
#endif

extern UtModuleInfo avl_UtModuleInfo;
extern unsigned char avl_UtActive[];

#ifndef UT_MODULE_INFO
#define UT_MODULE_INFO avl_UtModuleInfo
#endif /* UT_MODULE_INFO */

#ifndef UT_ACTIVE
#define UT_ACTIVE avl_UtActive
#endif /* UT_ACTIVE */

#ifdef __cplusplus
} /* extern "C" */
#endif
#endif /* UTE_AVL_MODULE_HEADER */
/*
 * End of file
 */
