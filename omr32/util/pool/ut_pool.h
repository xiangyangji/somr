/*
 *  Do not edit this file 
 *  Generated by TraceGen
 */
#ifndef UTE_POOL_MODULE_HEADER
#define UTE_POOL_MODULE_HEADER
#include "ute_module.h"
#if !defined(UT_DIRECT_TRACE_REGISTRATION)
#include "jni.h"
#endif /* !defined(UT_DIRECT_TRACE_REGISTRATION) */
#ifndef UT_TRACE_OVERHEAD
#define UT_TRACE_OVERHEAD 1
#endif
#ifndef UT_THREAD
#define UT_THREAD(thr) (void *)thr
#endif /* UT_THREAD */
#ifndef UT_STR
#define UT_STR(arg) #arg
#endif
#ifdef __cplusplus
extern "C" {
#endif

#ifdef __clang__
#include <unistd.h>
#define Trace_Unreachable() _exit(-1)
#else
#define Trace_Unreachable()
#endif

#if defined(UT_DIRECT_TRACE_REGISTRATION)
int32_t registerpoolWithTrace(UtInterface * utIntf, UtModuleInfo* containerName);
int32_t deregisterpoolWithTrace(UtInterface * utIntf);
#define UT_MODULE_LOADED(utIntf) registerpoolWithTrace((utIntf), NULL);
#define UT_MODULE_UNLOADED(utIntf) deregisterpoolWithTrace((utIntf));
#define UT_POOL_MODULE_LOADED(utIntf) registerpoolWithTrace((utIntf), NULL);
#define UT_POOL_MODULE_UNLOADED(utIntf) deregisterpoolWithTrace((utIntf));
#else /* defined(UT_DIRECT_TRACE_REGISTRATION) */
int32_t registerpoolWithTrace(JavaVM * vm, UtModuleInfo* containerName);
int32_t deregisterpoolWithTrace(JavaVM * vm);
#define UT_MODULE_LOADED(vm) registerpoolWithTrace((JavaVM *)(vm), NULL);
#define UT_MODULE_UNLOADED(vm) deregisterpoolWithTrace((JavaVM *)(vm));
#define UT_POOL_MODULE_LOADED(vm) registerpoolWithTrace((JavaVM *)(vm), NULL);
#define UT_POOL_MODULE_UNLOADED(vm) deregisterpoolWithTrace((JavaVM *)(vm));
#endif /* defined(UT_DIRECT_TRACE_REGISTRATION) */

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_new_Entry(P1, P2, P3, P4, P5, P6, P7) do { /* tracepoint name: pool.0 */ \
	if ((unsigned char) pool_UtActive[0] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((0u << 8) | pool_UtActive[0]), "\4\4\4\6\6\6\6", P1, P2, P3, P4, P5, P6, P7);} \
	} while(0)
#else
#define Trc_pool_new_Entry(P1, P2, P3, P4, P5, P6, P7)   /* tracepoint name: pool.0 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_new_TooLargeExit(P1) do { /* tracepoint name: pool.1 */ \
	if ((unsigned char) pool_UtActive[1] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((1u << 8) | pool_UtActive[1]), "\4", P1);} \
	} while(0)
#else
#define Trc_pool_new_TooLargeExit(P1)   /* tracepoint name: pool.1 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_new_Exit(P1) do { /* tracepoint name: pool.2 */ \
	if ((unsigned char) pool_UtActive[2] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((2u << 8) | pool_UtActive[2]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_new_Exit(P1)   /* tracepoint name: pool.2 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_kill_Entry(P1) do { /* tracepoint name: pool.3 */ \
	if ((unsigned char) pool_UtActive[3] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((3u << 8) | pool_UtActive[3]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_kill_Entry(P1)   /* tracepoint name: pool.3 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_kill_Exit() do { /* tracepoint name: pool.4 */ \
	if ((unsigned char) pool_UtActive[4] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((4u << 8) | pool_UtActive[4]), NULL);} \
	} while(0)
#else
#define Trc_pool_kill_Exit()   /* tracepoint name: pool.4 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_newElement_Entry(P1) do { /* tracepoint name: pool.5 */ \
	if ((unsigned char) pool_UtActive[5] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((5u << 8) | pool_UtActive[5]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_newElement_Entry(P1)   /* tracepoint name: pool.5 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_newElement_Exit(P1) do { /* tracepoint name: pool.6 */ \
	if ((unsigned char) pool_UtActive[6] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((6u << 8) | pool_UtActive[6]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_newElement_Exit(P1)   /* tracepoint name: pool.6 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_removeElement_Entry(P1, P2) do { /* tracepoint name: pool.7 */ \
	if ((unsigned char) pool_UtActive[7] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((7u << 8) | pool_UtActive[7]), "\6\6", P1, P2);} \
	} while(0)
#else
#define Trc_pool_removeElement_Entry(P1, P2)   /* tracepoint name: pool.7 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_removeElement_NotFound(P1, P2) do { /* tracepoint name: pool.8 */ \
	if ((unsigned char) pool_UtActive[8] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((8u << 8) | pool_UtActive[8]), "\6\6", P1, P2);} \
	} while(0)
#else
#define Trc_pool_removeElement_NotFound(P1, P2)   /* tracepoint name: pool.8 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_removeElement_Exit() do { /* tracepoint name: pool.9 */ \
	if ((unsigned char) pool_UtActive[9] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((9u << 8) | pool_UtActive[9]), NULL);} \
	} while(0)
#else
#define Trc_pool_removeElement_Exit()   /* tracepoint name: pool.9 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_do_Entry(P1, P2, P3) do { /* tracepoint name: pool.10 */ \
	if ((unsigned char) pool_UtActive[10] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((10u << 8) | pool_UtActive[10]), "\6\6\6", P1, P2, P3);} \
	} while(0)
#else
#define Trc_pool_do_Entry(P1, P2, P3)   /* tracepoint name: pool.10 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_do_Exit() do { /* tracepoint name: pool.11 */ \
	if ((unsigned char) pool_UtActive[11] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((11u << 8) | pool_UtActive[11]), NULL);} \
	} while(0)
#else
#define Trc_pool_do_Exit()   /* tracepoint name: pool.11 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_numElements_Entry(P1) do { /* tracepoint name: pool.12 */ \
	if ((unsigned char) pool_UtActive[12] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((12u << 8) | pool_UtActive[12]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_numElements_Entry(P1)   /* tracepoint name: pool.12 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_numElements_Exit(P1) do { /* tracepoint name: pool.13 */ \
	if ((unsigned char) pool_UtActive[13] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((13u << 8) | pool_UtActive[13]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_numElements_Exit(P1)   /* tracepoint name: pool.13 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_startDo_Entry(P1, P2) do { /* tracepoint name: pool.14 */ \
	if ((unsigned char) pool_UtActive[14] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((14u << 8) | pool_UtActive[14]), "\6\6", P1, P2);} \
	} while(0)
#else
#define Trc_pool_startDo_Entry(P1, P2)   /* tracepoint name: pool.14 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_startDo_NULLPool() do { /* tracepoint name: pool.15 */ \
	if ((unsigned char) pool_UtActive[15] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((15u << 8) | pool_UtActive[15]), NULL);} \
	} while(0)
#else
#define Trc_pool_startDo_NULLPool()   /* tracepoint name: pool.15 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_startDo_Empty() do { /* tracepoint name: pool.16 */ \
	if ((unsigned char) pool_UtActive[16] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((16u << 8) | pool_UtActive[16]), NULL);} \
	} while(0)
#else
#define Trc_pool_startDo_Empty()   /* tracepoint name: pool.16 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_startDo_Exit(P1) do { /* tracepoint name: pool.17 */ \
	if ((unsigned char) pool_UtActive[17] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((17u << 8) | pool_UtActive[17]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_startDo_Exit(P1)   /* tracepoint name: pool.17 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_nextDo_Entry(P1) do { /* tracepoint name: pool.18 */ \
	if ((unsigned char) pool_UtActive[18] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((18u << 8) | pool_UtActive[18]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_nextDo_Entry(P1)   /* tracepoint name: pool.18 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_nextDo_NextPuddle() do { /* tracepoint name: pool.19 */ \
	if ((unsigned char) pool_UtActive[19] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((19u << 8) | pool_UtActive[19]), NULL);} \
	} while(0)
#else
#define Trc_pool_nextDo_NextPuddle()   /* tracepoint name: pool.19 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_nextDo_Finished() do { /* tracepoint name: pool.20 */ \
	if ((unsigned char) pool_UtActive[20] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((20u << 8) | pool_UtActive[20]), NULL);} \
	} while(0)
#else
#define Trc_pool_nextDo_Finished()   /* tracepoint name: pool.20 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_nextDo_Exit(P1) do { /* tracepoint name: pool.21 */ \
	if ((unsigned char) pool_UtActive[21] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((21u << 8) | pool_UtActive[21]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_nextDo_Exit(P1)   /* tracepoint name: pool.21 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_sortFree_Entry(P1) do { /* tracepoint name: pool.22 */ \
	if ((unsigned char) pool_UtActive[22] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((22u << 8) | pool_UtActive[22]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_sortFree_Entry(P1)   /* tracepoint name: pool.22 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_sortFree_Conflict(P1, P2, P3) do { /* tracepoint name: pool.23 */ \
	if ((unsigned char) pool_UtActive[23] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((23u << 8) | pool_UtActive[23]), "\6\6\6", P1, P2, P3);} \
	} while(0)
#else
#define Trc_pool_sortFree_Conflict(P1, P2, P3)   /* tracepoint name: pool.23 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_sortFree_Exit() do { /* tracepoint name: pool.24 */ \
	if ((unsigned char) pool_UtActive[24] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((24u << 8) | pool_UtActive[24]), NULL);} \
	} while(0)
#else
#define Trc_pool_sortFree_Exit()   /* tracepoint name: pool.24 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_clear_Entry(P1) do { /* tracepoint name: pool.25 */ \
	if ((unsigned char) pool_UtActive[25] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((25u << 8) | pool_UtActive[25]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_clear_Entry(P1)   /* tracepoint name: pool.25 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_clear_Exit() do { /* tracepoint name: pool.26 */ \
	if ((unsigned char) pool_UtActive[26] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((26u << 8) | pool_UtActive[26]), NULL);} \
	} while(0)
#else
#define Trc_pool_clear_Exit()   /* tracepoint name: pool.26 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_ensureCapacity_Entry(P1, P2) do { /* tracepoint name: pool.27 */ \
	if ((unsigned char) pool_UtActive[27] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((27u << 8) | pool_UtActive[27]), "\6\6", P1, P2);} \
	} while(0)
#else
#define Trc_pool_ensureCapacity_Entry(P1, P2)   /* tracepoint name: pool.27 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_ensureCapacity_OutOfMemory(P1) do { /* tracepoint name: pool.28 */ \
	if ((unsigned char) pool_UtActive[28] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((28u << 8) | pool_UtActive[28]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_ensureCapacity_OutOfMemory(P1)   /* tracepoint name: pool.28 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_ensureCapacity_Exit(P1) do { /* tracepoint name: pool.29 */ \
	if ((unsigned char) pool_UtActive[29] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((29u << 8) | pool_UtActive[29]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_ensureCapacity_Exit(P1)   /* tracepoint name: pool.29 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_capacity_Entry(P1) do { /* tracepoint name: pool.30 */ \
	if ((unsigned char) pool_UtActive[30] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((30u << 8) | pool_UtActive[30]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_capacity_Entry(P1)   /* tracepoint name: pool.30 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_capacity_Exit(P1) do { /* tracepoint name: pool.31 */ \
	if ((unsigned char) pool_UtActive[31] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((31u << 8) | pool_UtActive[31]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_capacity_Exit(P1)   /* tracepoint name: pool.31 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_poolPuddle_new_Entry(P1) do { /* tracepoint name: pool.32 */ \
	if ((unsigned char) pool_UtActive[32] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((32u << 8) | pool_UtActive[32]), "\6", P1);} \
	} while(0)
#else
#define Trc_poolPuddle_new_Entry(P1)   /* tracepoint name: pool.32 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_poolPuddle_new_Exit(P1) do { /* tracepoint name: pool.33 */ \
	if ((unsigned char) pool_UtActive[33] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((33u << 8) | pool_UtActive[33]), "\6", P1);} \
	} while(0)
#else
#define Trc_poolPuddle_new_Exit(P1)   /* tracepoint name: pool.33 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_newWithPuddleAlloc_Entry(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10) do { /* tracepoint name: pool.34 */ \
	if ((unsigned char) pool_UtActive[34] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((34u << 8) | pool_UtActive[34]), "\4\4\4\4\6\6\6\6\6\6", P1, P2, P3, P4, P5, P6, P7, P8, P9, P10);} \
	} while(0)
#else
#define Trc_pool_newWithPuddleAlloc_Entry(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)   /* tracepoint name: pool.34 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_newWithPuddleAlloc_TooLargeExit(P1) do { /* tracepoint name: pool.35 */ \
	if ((unsigned char) pool_UtActive[35] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((35u << 8) | pool_UtActive[35]), "\10", P1);} \
	} while(0)
#else
#define Trc_pool_newWithPuddleAlloc_TooLargeExit(P1)   /* tracepoint name: pool.35 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_newWithPuddleAlloc_Exit(P1) do { /* tracepoint name: pool.36 */ \
	if ((unsigned char) pool_UtActive[36] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((36u << 8) | pool_UtActive[36]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_newWithPuddleAlloc_Exit(P1)   /* tracepoint name: pool.36 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_poolPuddle_startDo_Entry(P1, P2, P3, P4) do { /* tracepoint name: pool.37 */ \
	if ((unsigned char) pool_UtActive[37] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((37u << 8) | pool_UtActive[37]), "\6\6\6\4", P1, P2, P3, P4);} \
	} while(0)
#else
#define Trc_poolPuddle_startDo_Entry(P1, P2, P3, P4)   /* tracepoint name: pool.37 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_poolPuddle_startDo_ExitNullPoolPuddleExit() do { /* tracepoint name: pool.38 */ \
	if ((unsigned char) pool_UtActive[38] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((38u << 8) | pool_UtActive[38]), NULL);} \
	} while(0)
#else
#define Trc_poolPuddle_startDo_ExitNullPoolPuddleExit()   /* tracepoint name: pool.38 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_poolPuddle_startDo_EmptyExit() do { /* tracepoint name: pool.39 */ \
	if ((unsigned char) pool_UtActive[39] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((39u << 8) | pool_UtActive[39]), NULL);} \
	} while(0)
#else
#define Trc_poolPuddle_startDo_EmptyExit()   /* tracepoint name: pool.39 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_poolPuddle_startDo_Exit(P1) do { /* tracepoint name: pool.40 */ \
	if ((unsigned char) pool_UtActive[40] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((40u << 8) | pool_UtActive[40]), "\6", P1);} \
	} while(0)
#else
#define Trc_poolPuddle_startDo_Exit(P1)   /* tracepoint name: pool.40 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_newElement_ExitNoop() do { /* tracepoint name: pool.41 */ \
	if ((unsigned char) pool_UtActive[41] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((41u << 8) | pool_UtActive[41]), NULL);} \
	} while(0)
#else
#define Trc_pool_newElement_ExitNoop()   /* tracepoint name: pool.41 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_removeElement_ExitNoop() do { /* tracepoint name: pool.42 */ \
	if ((unsigned char) pool_UtActive[42] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((42u << 8) | pool_UtActive[42]), NULL);} \
	} while(0)
#else
#define Trc_pool_removeElement_ExitNoop()   /* tracepoint name: pool.42 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_sortFree_ExitNoop() do { /* tracepoint name: pool.43 */ \
	if ((unsigned char) pool_UtActive[43] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((43u << 8) | pool_UtActive[43]), NULL);} \
	} while(0)
#else
#define Trc_pool_sortFree_ExitNoop()   /* tracepoint name: pool.43 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_includesElement_ExitNoop() do { /* tracepoint name: pool.44 */ \
	if ((unsigned char) pool_UtActive[44] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((44u << 8) | pool_UtActive[44]), NULL);} \
	} while(0)
#else
#define Trc_pool_includesElement_ExitNoop()   /* tracepoint name: pool.44 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_includesElement_Entry(P1, P2) do { /* tracepoint name: pool.45 */ \
	if ((unsigned char) pool_UtActive[45] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((45u << 8) | pool_UtActive[45]), "\6\6", P1, P2);} \
	} while(0)
#else
#define Trc_pool_includesElement_Entry(P1, P2)   /* tracepoint name: pool.45 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_includesElement_ExitFullPuddle() do { /* tracepoint name: pool.46 */ \
	if ((unsigned char) pool_UtActive[46] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((46u << 8) | pool_UtActive[46]), NULL);} \
	} while(0)
#else
#define Trc_pool_includesElement_ExitFullPuddle()   /* tracepoint name: pool.46 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_includesElement_ExitFoundFree() do { /* tracepoint name: pool.47 */ \
	if ((unsigned char) pool_UtActive[47] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((47u << 8) | pool_UtActive[47]), NULL);} \
	} while(0)
#else
#define Trc_pool_includesElement_ExitFoundFree()   /* tracepoint name: pool.47 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_includesElement_ExitSuccess() do { /* tracepoint name: pool.48 */ \
	if ((unsigned char) pool_UtActive[48] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((48u << 8) | pool_UtActive[48]), NULL);} \
	} while(0)
#else
#define Trc_pool_includesElement_ExitSuccess()   /* tracepoint name: pool.48 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_includesElement_ExitOutOfScope() do { /* tracepoint name: pool.49 */ \
	if ((unsigned char) pool_UtActive[49] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((49u << 8) | pool_UtActive[49]), NULL);} \
	} while(0)
#else
#define Trc_pool_includesElement_ExitOutOfScope()   /* tracepoint name: pool.49 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_verify_Entry(P1) do { /* tracepoint name: pool.50 */ \
	if ((unsigned char) pool_UtActive[50] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((50u << 8) | pool_UtActive[50]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_verify_Entry(P1)   /* tracepoint name: pool.50 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_verify_ExitCorruptPuddle(P1, P2) do { /* tracepoint name: pool.51 */ \
	if ((unsigned char) pool_UtActive[51] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((51u << 8) | pool_UtActive[51]), "\6\6", P1, P2);} \
	} while(0)
#else
#define Trc_pool_verify_ExitCorruptPuddle(P1, P2)   /* tracepoint name: pool.51 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_verify_ExitSuccess(P1, P2, P3) do { /* tracepoint name: pool.53 */ \
	if ((unsigned char) pool_UtActive[53] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((53u << 8) | pool_UtActive[53]), "\6\4\4", P1, P2, P3);} \
	} while(0)
#else
#define Trc_pool_verify_ExitSuccess(P1, P2, P3)   /* tracepoint name: pool.53 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_verify_ExitInvalidFirstElement(P1, P2, P3) do { /* tracepoint name: pool.54 */ \
	if ((unsigned char) pool_UtActive[54] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((54u << 8) | pool_UtActive[54]), "\6\6\6", P1, P2, P3);} \
	} while(0)
#else
#define Trc_pool_verify_ExitInvalidFirstElement(P1, P2, P3)   /* tracepoint name: pool.54 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_verify_ExitFreeSlotInvalid(P1, P2, P3) do { /* tracepoint name: pool.55 */ \
	if ((unsigned char) pool_UtActive[55] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((55u << 8) | pool_UtActive[55]), "\6\6\6", P1, P2, P3);} \
	} while(0)
#else
#define Trc_pool_verify_ExitFreeSlotInvalid(P1, P2, P3)   /* tracepoint name: pool.55 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_newElement_FreeSlotInvalid(P1, P2, P3, P4) do { /* tracepoint name: pool.56 */ \
	if ((unsigned char) pool_UtActive[56] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((56u << 8) | pool_UtActive[56]), "\6\6\6\6", P1, P2, P3, P4);} \
	} while(0)
#else
#define Trc_pool_newElement_FreeSlotInvalid(P1, P2, P3, P4)   /* tracepoint name: pool.56 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_killWithoutPuddles_Entry(P1) do { /* tracepoint name: pool.57 */ \
	if ((unsigned char) pool_UtActive[57] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((57u << 8) | pool_UtActive[57]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_killWithoutPuddles_Entry(P1)   /* tracepoint name: pool.57 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_killWithoutPuddles_Exit() do { /* tracepoint name: pool.58 */ \
	if ((unsigned char) pool_UtActive[58] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((58u << 8) | pool_UtActive[58]), NULL);} \
	} while(0)
#else
#define Trc_pool_killWithoutPuddles_Exit()   /* tracepoint name: pool.58 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_verify_ExitNoPuddleList(P1) do { /* tracepoint name: pool.59 */ \
	if ((unsigned char) pool_UtActive[59] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((59u << 8) | pool_UtActive[59]), "\6", P1);} \
	} while(0)
#else
#define Trc_pool_verify_ExitNoPuddleList(P1)   /* tracepoint name: pool.59 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_verify_ExitNoNextAvailablePuddle(P1, P2) do { /* tracepoint name: pool.60 */ \
	if ((unsigned char) pool_UtActive[60] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((60u << 8) | pool_UtActive[60]), "\6\6", P1, P2);} \
	} while(0)
#else
#define Trc_pool_verify_ExitNoNextAvailablePuddle(P1, P2)   /* tracepoint name: pool.60 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_verify_ExitNumElementsMismatch(P1, P2, P3) do { /* tracepoint name: pool.61 */ \
	if ((unsigned char) pool_UtActive[61] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((61u << 8) | pool_UtActive[61]), "\6\4\4", P1, P2, P3);} \
	} while(0)
#else
#define Trc_pool_verify_ExitNumElementsMismatch(P1, P2, P3)   /* tracepoint name: pool.61 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_new_ArgumentTooLargeExit(P1, P2, P3) do { /* tracepoint name: pool.62 */ \
	if ((unsigned char) pool_UtActive[62] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((62u << 8) | pool_UtActive[62]), "\6\6\6", P1, P2, P3);} \
	} while(0)
#else
#define Trc_pool_new_ArgumentTooLargeExit(P1, P2, P3)   /* tracepoint name: pool.62 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_new_NoVerifyWithHolesExit() do { /* tracepoint name: pool.63 */ \
	if ((unsigned char) pool_UtActive[63] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((63u << 8) | pool_UtActive[63]), NULL);} \
	} while(0)
#else
#define Trc_pool_new_NoVerifyWithHolesExit()   /* tracepoint name: pool.63 */
#endif

#if UT_TRACE_OVERHEAD >= 1
#define Trc_pool_verify_ExitPrevPuddleMismatch(P1, P2, P3, P4) do { /* tracepoint name: pool.64 */ \
	if ((unsigned char) pool_UtActive[64] != 0){ \
		pool_UtModuleInfo.intf->Trace((void *)NULL, &pool_UtModuleInfo, ((64u << 8) | pool_UtActive[64]), "\6\6\6\4", P1, P2, P3, P4);} \
	} while(0)
#else
#define Trc_pool_verify_ExitPrevPuddleMismatch(P1, P2, P3, P4)   /* tracepoint name: pool.64 */
#endif

extern UtModuleInfo pool_UtModuleInfo;
extern unsigned char pool_UtActive[];

#ifndef UT_MODULE_INFO
#define UT_MODULE_INFO pool_UtModuleInfo
#endif /* UT_MODULE_INFO */

#ifndef UT_ACTIVE
#define UT_ACTIVE pool_UtActive
#endif /* UT_ACTIVE */

#ifdef __cplusplus
} /* extern "C" */
#endif
#endif /* UTE_POOL_MODULE_HEADER */
/*
 * End of file
 */
