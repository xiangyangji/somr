datfilename=J9TraceFormat.dat
executable=pool
pool.0 2 1 3 N Trc_pool_new_Entry " >pool_new(structSize=%u, minNumberElements=%u elementAlignment=%u poolFlags=0x%zx, memAlloc=%p, memFree=%p, userData=%p)"
pool.1 4 1 1 N Trc_pool_new_TooLargeExit " <pool_new too large (puddleAllocSize=%u)"
pool.2 4 1 3 N Trc_pool_new_Exit " <pool_new(result=%p)"
pool.3 2 1 3 N Trc_pool_kill_Entry " >pool_kill(%p)"
pool.4 4 1 3 N Trc_pool_kill_Exit " <pool_kill"
pool.5 2 1 4 N Trc_pool_newElement_Entry " >pool_newElement(pool=%p)"
pool.6 4 1 4 N Trc_pool_newElement_Exit " <pool_newElement(result=%p)"
pool.7 2 1 4 N Trc_pool_removeElement_Entry " >pool_removeElement(pool=%p, anElement=%p)"
pool.8 1 1 1 N Trc_pool_removeElement_NotFound "* pool_removeElement -- %p not found in any puddle of %p"
pool.9 4 1 4 N Trc_pool_removeElement_Exit " <pool_removeElement"
pool.10 2 1 4 N Trc_pool_do_Entry " >pool_do(aPool=%p, aFunction=%p, userData=%p)"
pool.11 4 1 4 N Trc_pool_do_Exit " <pool_do"
pool.12 2 1 4 N Trc_pool_numElements_Entry " >pool_numElements(aPool=%p)"
pool.13 4 1 4 N Trc_pool_numElements_Exit " <pool_numElements(result=%zu)"
pool.14 2 1 4 N Trc_pool_startDo_Entry " >pool_startDo(aPool=%p, state=%p)"
pool.15 1 1 1 N Trc_pool_startDo_NULLPool "* pool_startDo - pool is NULL"
pool.16 4 1 4 N Trc_pool_startDo_Empty " <pool_startDo - no elements"
pool.17 4 1 4 N Trc_pool_startDo_Exit " <pool_startDo - first element is %p"
pool.18 2 1 4 N Trc_pool_nextDo_Entry " >pool_nextDo(state=%p)"
pool.19 4 1 4 N Trc_pool_nextDo_NextPuddle " <pool_nextDo - advance to next puddle"
pool.20 4 1 4 N Trc_pool_nextDo_Finished " <pool_nextDo - no more elements"
pool.21 4 1 4 N Trc_pool_nextDo_Exit " <pool_nextDo - result=%p"
pool.22 2 1 3 N Trc_pool_sortFree_Entry " >pool_sortFree(%p)"
pool.23 1 1 1 N Trc_pool_sortFree_Conflict "* pool_sortFree - conflict at element %p in pool %p with 0x%zx"
pool.24 4 1 3 N Trc_pool_sortFree_Exit " <pool_sortFree"
pool.25 2 1 3 N Trc_pool_clear_Entry " >pool_clear(%p)"
pool.26 4 1 3 N Trc_pool_clear_Exit " <pool_clear"
pool.27 2 1 3 N Trc_pool_ensureCapacity_Entry " >pool_ensureCapacity(aPool=%p, newCapacity=%zu)"
pool.28 1 1 1 N Trc_pool_ensureCapacity_OutOfMemory "* pool_ensureCapacity - failed to allocate memory to grow capacity to %zu"
pool.29 4 1 3 N Trc_pool_ensureCapacity_Exit " <pool_ensureCapacity(result=%zu)"
pool.30 2 1 3 N Trc_pool_capacity_Entry " >pool_capacity(aPool=%p)"
pool.31 4 1 3 N Trc_pool_capacity_Exit " <pool_capacity(result=%zu)"
pool.32 2 1 3 N Trc_poolPuddle_new_Entry " >poolPuddle_new(%p)"
pool.33 4 1 3 N Trc_poolPuddle_new_Exit " <poolPuddle_new exiting with %p"
pool.34 2 1 3 N Trc_pool_newWithPuddleAlloc_Entry " >pool_newWithPuddleAlloc(%d, %d, %d, %x, %p, %p,	%p, %p, %p, %p)"
pool.35 4 1 3 N Trc_pool_newWithPuddleAlloc_TooLargeExit " <pool_newWithPuddleAlloc exit: puddle alloc size %lld too large"
pool.36 4 1 3 N Trc_pool_newWithPuddleAlloc_Exit " <pool_newWithPuddleAlloc exit with %p"
pool.37 2 1 3 N Trc_poolPuddle_startDo_Entry " >poolPuddle_startDo(aPool=%p, currentPuddle=%p, lastHandle=%p, followNextPointers=%d)"
pool.38 4 1 3 N Trc_poolPuddle_startDo_ExitNullPoolPuddleExit " <poolPuddle_startDo exiting because of NULL puddle"
pool.39 4 1 3 N Trc_poolPuddle_startDo_EmptyExit " <poolPuddle_startDo exiting because the puddle is empty"
pool.40 4 1 3 N Trc_poolPuddle_startDo_Exit " <poolPuddle_startDo exiting with %p"
pool.41 4 1 3 N Trc_pool_newElement_ExitNoop " <pool_newElement exiting as one or more parameters is NULL"
pool.42 4 1 3 N Trc_pool_removeElement_ExitNoop " <pool_removeElement exiting as one or more parameters is NULL"
pool.43 4 1 3 N Trc_pool_sortFree_ExitNoop " <pool_sortFree exiting as one or more parameters is NULL"
pool.44 4 1 3 N Trc_pool_includesElement_ExitNoop " <pool_includesElement exiting as one or more parameters is NULL"
pool.45 2 1 3 N Trc_pool_includesElement_Entry " >pool_includesElement(aPool=%p, anElement=%p)"
pool.46 4 1 3 N Trc_pool_includesElement_ExitFullPuddle " <pool_includesElement exiting with TRUE as puddle containing element is full"
pool.47 4 1 3 N Trc_pool_includesElement_ExitFoundFree " <pool_includesElement exiting with FALSE as element has been freed"
pool.48 4 1 3 N Trc_pool_includesElement_ExitSuccess " <pool_includesElement exiting with TRUE as element is currently allocated"
pool.49 4 1 3 N Trc_pool_includesElement_ExitOutOfScope " <pool_includesElement exiting with FALSE as element is not in scope of the pool"
pool.50 2 1 1 N Trc_pool_verify_Entry " >pool_verify(aPool=%p)"
pool.51 4 1 1 N Trc_pool_verify_ExitCorruptPuddle " <pool_verify failed pool %p corrupt puddle %p"
pool.52 4 1 1 N Trc_pool_verify_ExitNoActive " <pool_verify failed pool %p active puddle %p not found"
pool.53 4 1 1 N Trc_pool_verify_ExitSuccess " <pool_verify success pool %p numElements %d numPuddles %d"
pool.54 4 1 1 N Trc_pool_verify_ExitInvalidFirstElement " <pool_verify failed pool %p puddle %p invalid first element %p"
pool.55 4 1 1 N Trc_pool_verify_ExitFreeSlotInvalid " <pool_verify failed pool %p puddle %p first free slot invalid %p"
pool.56 0 1 1 N Trc_pool_newElement_FreeSlotInvalid "  pool_newElement pool %p puddle %p free slot in element %p invalid %p"
pool.57 2 1 3 N Trc_pool_killWithoutPuddles_Entry " >pool_killWithoutPuddles(%p)"
pool.58 4 1 3 N Trc_pool_killWithoutPuddles_Exit " <pool_killWithoutPuddles"
pool.59 4 1 1 N Trc_pool_verify_ExitNoPuddleList " <pool_verify pool %p has no puddle list"
pool.60 4 1 1 N Trc_pool_verify_ExitNoNextAvailablePuddle " <pool_verify failed pool %p next available puddle %p not found"
pool.61 4 1 1 N Trc_pool_verify_ExitNumElementsMismatch " <pool_verify failed pool %p element count mismatch found %d expected %d"
pool.62 4 1 1 N Trc_pool_new_ArgumentTooLargeExit " <pool_new too large (structSize=%zu, minNumberElements=%zu elementAlignment=%zu)"
pool.63 4 1 1 N Trc_pool_new_NoVerifyWithHolesExit " <pool_new POOL_VERIFY_FREE_LIST unsupported when POOL_USES_HOLES"
pool.64 4 1 1 N Trc_pool_verify_ExitPrevPuddleMismatch " <pool_verify failed pool %p puddle %p prev puddle not %p avail %d"
